//*****************************************************************************
//
// logger.h - Widget handler functions exported from logger.cxx
//
// Copyright (c) 2010-2017 Texas Instruments Incorporated.  All rights reserved.
// Software License Agreement
// 
// Texas Instruments (TI) is supplying this software for use solely and
// exclusively on TI's microcontroller products. The software is owned by
// TI and/or its suppliers, and is protected under applicable copyright
// laws. You may not combine this software with "viral" open-source
// software in order to form a larger program.
// 
// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
// DAMAGES, FOR ANY REASON WHATSOEVER.
// 
// This is part of revision 2.1.4.178 of the Tiva Firmware Development Package.
//
//*****************************************************************************
#ifndef _LOGGER_H_
#define _LOGGER_H_

#ifndef __WIN32
#include <pthread.h>
#include <stdbool.h>
#include <unistd.h>
#else
#include <process.h>
#endif
#include <math.h>
#include <iostream>
#include <fstream>
#include <string>
#include <FL/x.H>
#include <FL/fl_ask.H>
#include <FL/Fl_Output.H>
#include <FL/Fl_Light_Button.H>
#include "CStripChart.h"
#include "CLoggerUI.h"

//*****************************************************************************
//
// The number of channels of sampled data in a packet sent from the EK board.
//
//*****************************************************************************
#define NUM_PACKET_CHANNELS 16

//*****************************************************************************
//
// Indices of the entries in the menu_mainMenu array of CLoggerUI.
// NB: These must match the array generated by FLUID in CLoggerIU.cxx!
//
//*****************************************************************************
#define MENU_INDEX_FILE     0
#define MENU_INDEX_LOG_FILE 1
#define MENU_INDEX_START    2
#define MENU_INDEX_STOP     3
#define MENU_INDEX_QUIT     4

//*****************************************************************************
//
// String identifiers used when updating the various status boxes.  These
// labels must match with the strings found in logger.cxx's g_pcStrings[]
// array.
//
//*****************************************************************************
#define INDEX_NO_FILE        ((void *)0)
#define INDEX_APPEND         ((void *)1)
#define INDEX_OVERWRITE      ((void *)2)
#define INDEX_LOGGING        ((void *)3)
#define INDEX_SEARCHING      ((void *)4)
#define INDEX_LISTENING      ((void *)5)
#define INDEX_SELECT_PC_SAVE ((void *)6)
#define INDEX_DISCONNECTED   ((void *)7)
#define INDEX_READING        ((void *)8)

//*****************************************************************************
//
// The application string table.
//
//*****************************************************************************
extern const char *g_pcStrings[];

//*****************************************************************************
//
// Prototypes for widget handler functions.
//
//*****************************************************************************
extern void HandleButton(Fl_Light_Button *hButton, void *pvData);

//*****************************************************************************
//
// Message handlers scheduled from the worker thread but called in the context
// of the main loop.
//
//*****************************************************************************
extern void UpdateOverwriteStatus(void *pvStringId);
extern void UpdateApplicationStatus(void *pvStringId);
extern void UpdateCOMStatus(void *pvStringId);
extern void HandleNewPacket(void *pvPacket);

//*****************************************************************************
//
// This structure defines the packet as delivered from the worker thread to
// the handler function.  Note that this is different from the packet structure
// received via the COM port since the worker thread checks the packet validity
// and reformats to make life a bit easier on the handler.
//
// The structure as received is:
//
// unsigned short usMarker     (0x5351 or "QS")
// unsigned long ulSeconds     (Unix timestamp)
// unsigned short usSubseconds (1/32768ths of a second)
// unsigned short usItemMask   (1 bit per populated sample)
// short sItems[num samples]   (where num samples equals 1 count in usItemMask)
// unsigned short usChecksum   (add whole packet as 16 bit words, result = 0)
//
//*****************************************************************************
typedef struct
{
    unsigned long ulTimestamp;
    unsigned long ulSubSeconds;
    unsigned long ulChannelMask;
    int piSamples[NUM_PACKET_CHANNELS];
}
tSamplePacket;

//*****************************************************************************
//
// A label defining the maximum number of bytes that could be received for a
// single packet sent from the logger device.
//
// NOTE: this is an absolute maximum, 12 bytes for the header and checksum, 32 bytes for sensor data
//      the only way to change this / have more than 16 sensors is to increase the channelMask from
//      16 bits to 32 bits and thus increase the number of possible sensors. (need to change on both
//      embedded side and windows side to match)
//
//*****************************************************************************
#define MAX_LOGGER_PACKET_SIZE (12 + (16 * 2))

//*****************************************************************************
//
// A structure containing all the bits and pieces needed to tie samples in a
// data packet from the board to a given trace on the user interface.
//
//*****************************************************************************
typedef struct
{
    Fl_Light_Button *pButton;
    Fl_Output *pOutput;
    CStripChart *pStripChart;
    unsigned long ulMask;
    const char *pcName;
    const char *pcUnit;
}
tChannelControls;

extern tChannelControls g_ChannelControls[];

#endif /* _LOGGER_H_ */
